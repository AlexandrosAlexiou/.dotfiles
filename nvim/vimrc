" ----------------------------------------- vim: set sw=2: -----------------------------------------
"
"                                 ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
"                                 ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
"                                 ██║   ██║██║██╔████╔██║██████╔╝██║
"                                 ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"                                  ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"                                   ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
" Author: Tryfon Tsakiris
"  Email: tr.tsakiris@gmail.com
"    URL: https://raw.githubusercontent.com/tsakirist/dotfiles/master/nvim/vimrc
" --------------------------------------------------------------------------------------------------

" ----------------------------------- 1. Compatible {{{

" Vim defaults to `compatible` when selecting a vimrc with the command-line '-u' argument.
" Override that behaviour to nocompatible.
if &compatible
  set nocompatible
endif

" }}}

" ----------------------------------- 2. Plugins {{{

" ----------------------------------- 1. Plugin installer {{{

" Automate the process of installing vim-plug when required
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
     \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Install missing plugins during startup
autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  \| PlugInstall --sync | q | source $MYVIMRC
\| endif

" }}}

" ----------------------------------- 2. Plugin list {{{

" Plugins will be downloaded under the specified directory
call plug#begin('~/.vim/plugged')

" Colorschemes
" Plug 'joshdick/onedark.vim'
Plug 'ful1e5/onedark.nvim'
Plug 'doums/darcula'
Plug 'EdenEast/nightfox.nvim'

" Lightline statusline and tabline
Plug 'itchyny/lightline.vim', { 'on': [] }
Plug 'mengelbrecht/lightline-bufferline', { 'on': [] }

" Airline statusline/tabline
Plug 'vim-airline/vim-airline', { 'on': [] }
Plug 'vim-airline/vim-airline-themes', { 'on': [] }

" Lua-based statusline
Plug 'hoob3rt/lualine.nvim'

" A temporary tabline for buffers, untill I find a better one
Plug 'pacha/vem-tabline'

" Add file type icons to various plugins
Plug 'kyazdani42/nvim-web-devicons'

" Fancy starting screen
Plug 'mhinz/vim-startify'

" Distraction free mode
Plug 'junegunn/goyo.vim'

" Display available keybinds in pop-up
Plug 'liuchengxu/vim-which-key'

" Measure the startup time of vim
Plug 'dstein64/vim-startuptime'

" An interactive calculator inside a buffer
Plug 'fedorenchik/VimCalc3'

" Some useful keymappings
Plug 'tpope/vim-unimpaired'

" Supecharged substitute command and more
Plug 'tpope/vim-abolish'

" Comment lines easily
Plug 'scrooloose/nerdcommenter'

" Display indentation levels with lines
Plug 'lukas-reineke/indent-blankline.nvim'

" Surround mappings for enclosed text
Plug 'tpope/vim-surround'

" Auto insert brackets, parentheses, etc
Plug 'windwp/nvim-autopairs'
Plug 'windwp/nvim-ts-autotag'

" Alternate between absolute/relative numbers
Plug 'jeffkreeftmeijer/vim-numbertoggle'

" Text alignment
Plug 'junegunn/vim-easy-align'

" Rooter changes the working directory to the project root when you open a file or directory
Plug 'airblade/vim-rooter'

" Close buffers without losing splits/windows
Plug 'moll/vim-bbye'

" Remove all buffers except current
Plug 'numtostr/BufOnly.nvim', { 'on': 'BufOnly' }

" Easy resize windows/splits
Plug 'sedm0784/vim-resize-mode'

" Vim wrapper for UNIX shell commands
" :SudoWrite, :SudoRead doesn't work with nvim
Plug 'tpope/vim-eunuch'

" Write/Read files with sudo from within vim
Plug 'lambdalisue/suda.vim'

" Use terminal in a floating pop up window
Plug 'voldikss/vim-floaterm'

" Color highlighter
Plug 'norcalli/nvim-colorizer.lua'

" Highlight/Underline word under cursor
Plug 'dominikduda/vim_current_word'

" Easily locate cursor after search
Plug 'inside/vim-search-pulse'

" Visual indication when jumping long distances
Plug 'edluffy/specs.nvim'

" Highlight first occurences of characters in words, e.g. to move with f{char}
Plug 'unblevable/quick-scope'

" Show an indication in the sign column for git diffs
Plug 'mhinz/vim-signify'

" A git wrapper for vim
Plug 'tpope/vim-fugitive'

" A visual git commit browser
Plug 'junegunn/gv.vim'

" Enables :GBrowse to open GitHub urls from vim
Plug 'tpope/vim-rhubarb'

" More pleasant commit experience
Plug 'rhysd/committia.vim'

" Git floating popup with blame-commit details
Plug 'rhysd/git-messenger.vim'

" Git blamer with inline text
Plug 'APZelos/blamer.nvim'

" Switch between single-line and multiline forms of code
Plug 'AndrewRadev/splitjoin.vim'

" Peak lines easiliy with :<number>
Plug 'nacro90/numb.nvim'

" File explorer tree for neovim
Plug 'kyazdani42/nvim-tree.lua'

" Treesitter incremental parsing library
Plug 'nvim-treesitter/nvim-treesitter', { 'do': ':TSUpdate' }
Plug 'nvim-treesitter/nvim-treesitter-textobjects'
Plug 'nvim-treesitter/playground'

" Telescope fuzzy finder
Plug 'nvim-lua/popup.nvim'
Plug 'nvim-lua/plenary.nvim'
Plug 'nvim-telescope/telescope.nvim'
Plug 'nvim-telescope/telescope-fzf-native.nvim', { 'do': 'make' }

" The world-renowned fuzzy finder FZF
" This will try to install FZF outside of vim plug directory
Plug 'junegunn/fzf', { 'dir': '~/.fzf','do': './install --key-bindings --completion --no-update-rc' }
Plug 'junegunn/fzf.vim'

" LSP related
Plug 'neovim/nvim-lspconfig'
Plug 'kabouzeid/nvim-lspinstall'
Plug 'hrsh7th/nvim-cmp'
Plug 'hrsh7th/cmp-nvim-lsp'
Plug 'hrsh7th/cmp-nvim-lua'
Plug 'hrsh7th/cmp-buffer'
Plug 'hrsh7th/cmp-path'
Plug 'ray-x/lsp_signature.nvim'
Plug 'kosayoda/nvim-lightbulb'
Plug 'weilbith/nvim-code-action-menu', { 'on': 'CodeActionMenu' }

" Goto preview in a floating window
Plug 'rmagatti/goto-preview'

" Viewer and finder for LSP symbols and tags
Plug 'liuchengxu/vista.vim'

" Pretty list of showing diagnostics, telescope results etc
Plug 'folke/trouble.nvim'

" A fancy, configurable, notification manager
Plug 'rcarriga/nvim-notify'

" -------------------------

" List ends here. Plugins become visible to Vim after this call
call plug#end()

" }}}

" }}}

" ----------------------------------- 3. Settings {{{

" ----------------------------------- 3.1 Options {{{

" Syntax highlighting
syntax on

" Set true colors inside nvim
set termguicolors

" Don't show the (INSERT, REPLACE, VISUAL) modes on the last line
set noshowmode

" Highlight the current line and also highlight the column @120 (ruler)
set colorcolumn=120
set cursorline

" Set hidden to on so as to be able to change buffers without saving first
set hidden

" Set hybrid line numbers
set number relativenumber

" Set the number of columns used for line numbers
set numberwidth=1

" Insert spaces when <Tab> is pressed
set expandtab

" Controls the number of space characters inserted when pressing the tab key
set tabstop=4

" Controls the number of space characters inserted for identation
set shiftwidth=4

" Use the indentation level of the previous line when pressing enter
set autoindent

" Do smart auto-indenting when starting a new line
set smartindent

" The two following options are used alongside with linebreak, but I currently use textwidth
" Make wrapped lines to visually indent properly
" set breakindent

" Set the visual character to be shown for wrapped lines
" set showbreak=\ \\_
set showbreak=↪\

" This makes searches case insensitive
set ignorecase

" This makes searches with a single capital letter to be case sensitive
set smartcase

" This highlights the search pattern as you type
set incsearch

" This provides live feedback when substituting
set inccommand=split

" Open new splits/windows always below and right
set splitbelow splitright

" Set automatic wrap to display lines in next line (this is the default)
set wrap

" Set the maximum text width before vim automatically wraps it, this inserts the EOL character
" This is considered a hard-wrap, one can use linebreak to soft-wrap the lines w/o inserting EOL
set textwidth=120

" Set default encoding
set encoding=UTF-8

" Set the fileformat to unix because windows line endings are bad
set fileformat=unix

" This is used to control the Ctrl + C command and copy to the system's clipboard
" set clipboard+=unnamedplus
set clipboard^=unnamed,unnamedplus

" This option will render characters for spaces, tabs etc
" set listchars=trail:·,tab:»·,eol:↲,nbsp:␣,extends:⟩,precedes:⟨
" set listchars=eol:↴,¬,
set list
set listchars=nbsp:␣,extends:⟩,precedes:⟨,trail:·,tab:»·

" The number of lines to show above/below when navigating
set scrolloff=5

" This sets the folding method, the default markers are {{{  }}}
set foldmethod=marker

" Set fold enabled
set foldenable

" Foldopen dictates how folds open, jump means it will open with 'gg', 'G'
set foldopen+=jump

" Enable mouse support
set mouse=a

" Enable modeline to allow file secific settings
" e.g. vim: set sw=2:
set modeline

" Make updates happen faster
set updatetime=1000

" Keep windows equal in size after split, close etc
set equalalways

" Set transparency for the popup window
set pumblend=15

" Set completeopt to have a better completion experience
set completeopt=menuone,noinsert,noselect

" Avoid showing message extra message when using completion
set shortmess+=c

" Set rg as the grep program
if executable('rg')
  set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

" }}}

" ----------------------------------- 3.2 Colorscheme {{{

" Convenient function to set-up onedark colorscheme
function! s:SetOneDarkColorScheme() abort
  if !functions#PluginLoaded('onedark.nvim')
    echoerr "Error: 'onedark.nvim' colorscheme has not been installed or loaded!"
    return
  endif
lua<<EOF
-- Setup onedark
require'onedark'.setup {
  transparent = false,
  darkSidebar = true,
  darkFloat = true,
  msgAreaStyle = "bold",
  sidebars = {
    "vista_kind",
    "terminal",
  },
  colors = {
    border_highlight = "#5c6370",
  },
  keywordStyle = "NONE",
}
EOF
  " This needs to be set if we want to show the eol character
  " highlight! link NonText WhiteSpace
  " Set the promptPrefix color to purple
  highlight TelescopePromptPrefix guibg=#282c34 guifg=#c678dd
  " Re-set the color for the folded sections
  highlight Folded guibg=Black guifg=DarkGray
endfunction

function! s:SetNightfoxColorScheme() abort
lua<<EOF
-- Setup nightfox
local nightfox = require'nightfox'
nightfox.setup {
  fox = "nordfox"
  }
nightfox.load()
EOF
endfunction

" Convenient commands to set-up my colorschemes
command! OneDarkColorScheme call s:SetOneDarkColorScheme()
command! NightFoxColorScheme call s:SetNightfoxColorScheme()

" The default colorscheme to use
let s:_colorScheme='nightfox.nvim'

if functions#PluginLoaded('onedark.nvim') && s:_colorScheme=='onedark.nvim'
  call s:SetOneDarkColorScheme()
elseif functions#PluginLoaded('nightfox.nvim') && s:_colorScheme=='nightfox.nvim'
  call s:SetNightfoxColorScheme()
endif

" }}}

" }}}

" ----------------------------------- 4. Autocommands {{{

" Format options configuration:
" 't': is required in format options to wrap text in insert mode
" 'l': a line that is longer than textwidth may not be wraped if 'l' is in format options
" 'r': enables the <CR> key from autocommenting when pressing enter in line that contains a comment, enables javadoc
" 'o': don't insert comment when pressing 'o' or 'O'
" 'q': allow formatting comments with gq
autocmd BufEnter * set fo+=t fo+=r fo-=l fo-=o fo+=q

" Remove trailing whitespaces on file save
autocmd BufWritePre * call functions#TrimTrailingWhitespace()

" This is used to preserve the clipboard when vim exits
autocmd VimLeave * call system("xclip -selection clipboard -i", getreg("+"))

" This will automatically resize windows/splits when resizing host window
autocmd VimResized * wincmd =

" Autocmd for vim-signify
if functions#PluginLoaded('vim-signify')
  " Show the hunk number when jumping to a hunk
  autocmd User SignifyHunk call functions#ShowCurrentHunk()
endif

" Autocmd for vim-eunuch
if functions#PluginLoaded('vim-eunuch')
  " Remove SudoWrite, SudoEdit from the commands as they do not work
  autocmd VimEnter * :delcommand SudoWrite | :delcommand SudoEdit
endif

" Autocmd for git blamer
if functions#PluginLoaded('blamer.nvim')
  " Hide blamer on startup
  autocmd VimEnter * :BlamerHide
endif

" Autocmd for lsp lightbulb code-action
if functions#PluginLoaded('nvim-lightbulb')
  autocmd CursorHold,CursorHoldI * lua require'nvim-lightbulb'.update_lightbulb{ sign = { enabled = true } }
endif

" Autocmd for highlighting yanked text
augroup LuaHighlightGroup
  autocmd!
  autocmd TextYankPost * silent! lua vim.highlight.on_yank()
augroup END

" Autocmd configurations for :term
augroup TermAuGroup
  " Clear old autocommands of this group
  autocmd!
  " Automatically enter in insert mode when in terminal pane
  autocmd TermOpen,BufEnter,WinEnter * if &buftype == 'terminal' | :startinsert | endif
  " Disable linenumbering when in terminal
  autocmd TermOpen * setlocal nonumber norelativenumber
augroup END

" Autocmd configuration for NvimTree
if functions#PluginLoaded('nvim-tree.lua')
  augroup NvimTreeAuGroup
    " Clear old autocommands of this group
    autocmd!
    " This will resize the NvimTree depending on its focused state 60 - 40
    autocmd WinEnter NvimTree :vertical resize 60
    autocmd WinLeave NvimTree :vertical resize 40
  augroup END
endif

" }}}

" ----------------------------------- 5. Extra configurations {{{

" Add persistent undo for vim
" ---------------------------
if has('persistent_undo')
  " Define the paths to store the persistent undo files
  let vim_path=expand('$HOME/.vim')
  let undo_path=expand('$HOME/.vim/undo-dir')
  " Create the required directories if needed with the appropriate permissions
  if !isdirectory(vim_path)
    call mkdir(vim_path, "", 0770)
  endif
  if !isdirectory(undo_path)
    call mkdir(undo_path, "", 0700)
  endif
  " Point vim to the defined undo directory and enable undo persistence
  let &undodir=undo_path
  set undofile
endif

" }}}

" ----------------------------------- 6. Keybindings {{{

" Keymap to source the vimrc automatically
nnoremap <silent> <leader>sc :source $MYVIMRC<CR>

" Toggle Goyo - distraction free writing
nnoremap <silent> <F1> :Goyo<CR>

" Toggle between folds
nnoremap <expr> <F2> &foldlevel ? 'zM' :'zR'

" Fill the current line with a leading "<Space><prev_line_cols>[-]
nnoremap <expr> <F3> ':call functions#Fill(45)\<CR>'

" Change buffers quickly
nnoremap <silent> <leader>bn :bnext<CR>
nnoremap <silent> <leader>bp :bprevious<CR>

nnoremap <silent> <Tab>   :bnext<CR>
nnoremap <silent> <S-Tab> :bprevious<CR>

" List buffers and prepend :b on the cmd line
nnoremap <leader>bf :ls<CR>:b<Space>

" Search within buffers and send results in the qflist
" nnoremap <leader>bs :cex []<Bar>bufdo vimgrepadd @@g %<Bar>cw<S-Left><S-Left><Right>
nnoremap <leader>bs :cex []<Bar>bufdo vimgrepadd //gj %<Bar>Trouble quickfix<S-Left><S-Left><S-Left><Right>

" Split comma separated arguments of function from one-line-all to one-line-each
" f)%:       finds the starting '(' of the function signature
" csbb:      changes surround blockwise from ( to ( on its own line
" s/,/,\r/g: substitutes each ',' with ',' and carriage return '\r', one-arg-per-line
" J:         joins the last ')' to the last argument
" vib=:      select the surrounding text inside '()' and indent it visually
" gv>:       re-select the surrounding text and indent it manually
" TODO: need to check my C++ indentation opts, last one shouldn't be needed
map <leader>bp f)%cSbbj:s/,/,\r/g<CR>Jvib=gv><Esc>:nohl<CR>

" Use bbye plugin's :Bdelete to close buffer w/o losing splits/windows
nnoremap <silent> <leader>bd :Bdelete<CR>

" Close all buffers except the current one
nnoremap <silent> <leader>bo :BufOnly<CR>

" Typing %% on the command line will expand to active buffer's path
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Use space to toggle fold
nnoremap <Space> za<CR>

" Keybinds to move lines up and down
nnoremap <silent> <C-S-Up>   :m-2<CR>==
nnoremap <silent> <C-S-Down> :m+<CR>==
inoremap <silent> <C-S-Up>   <Esc>:m-2<CR>==gi
inoremap <silent> <C-S-Down> <Esc>:m+<CR>==gi
vnoremap <silent> <C-S-Up>   :m '<-2<CR>gv=gv
vnoremap <silent> <C-S-Down> :m '>+1<CR>gv=gv

nnoremap <silent> <C-k> :m-2<CR>==
nnoremap <silent> <C-j> :m+<CR>==
vnoremap <silent> <C-k> :m '<-2<CR>gv=gv
vnoremap <silent> <C-j> :m '>+1<CR>gv=gv

" Duplicate the current line
" 't' command is a synonym for copy
nnoremap <silent> <leader>d :t.<CR>
inoremap <silent> <leader>d <Esc>:t.<CR>
vnoremap <silent> <leader>d :t.<CR>

" Hitting ESC when inside a :term to get into normal mode
tnoremap <Esc> <C-\><C-N>

" Save files with ctrl+s
" Use :update instead of :write, to only write the file when modified
nnoremap <silent> <C-s> :update<CR>
inoremap <silent> <C-s> <Esc>:update<CR>
vnoremap <silent> <C-s> <Esc>:update<CR>

" Keymaps to quit current buffer with ctrl+q
nnoremap <silent> <C-q> :q<CR>
inoremap <silent> <C-q> <Esc>:q<CR>
vnoremap <silent> <C-q> <Esc>:q<CR>

" Keymap to quit all buffers with shift+q
nnoremap <silent> Q <Esc>:qa<CR>

" Quick movements in Insert mode without having to change to Normal mode
inoremap <C-h> <C-o>h
inoremap <C-l> <C-o>l
inoremap <C-j> <C-o>j
inoremap <C-k> <C-o>k
inoremap <C-b> <C-o>B
inoremap <C-e> <C-o>E<C-o>l
inoremap <C-a> <C-o>A
inoremap <C-^> <C-o><C-^>

" Keep Visual mode selection when indenting text
xmap > >gv
xmap < <gv

" Make visual pasting a word to not update the unnamed register
" Thus, allowing us to repeatedly paste the word. {"_ : black-hole register}
vnoremap p "_dP

" The '&' command repeats last substitution and the
" second '&' keeps the previous flags that were used
" So, usually we want to have this as the default behavior
nnoremap & :&&<CR>
xnoremap & :&&<CR>

" Remind myself to stop using the god damn arrow keys
nnoremap <silent> <Left>  :echoe "Use h"<CR>
nnoremap <silent> <Right> :echoe "Use l"<CR>
nnoremap <silent> <Up>    :echoe "Use k"<CR>
nnoremap <silent> <Down>  :echoe "Use j"<CR>
vnoremap <silent> <Left>  :<C-u>echoe "Use h"<CR>
vnoremap <silent> <Right> :<C-u>echoe "Use l"<CR>
vnoremap <silent> <Up>    :<C-u>echoe "Use k"<CR>
vnoremap <silent> <Down>  :<C-u>echoe "Use j"<CR>

" Clear highlighting with escape when in normal mode
" https://stackoverflow.com/a/1037182/6654329
nnoremap <silent> <Esc> :noh<return><Esc>
nnoremap <silent> <Esc>^[ <Esc>^[

" Commands/Keymaps to open terminals horizontally and vertically
command! -nargs=* HT split  | terminal <args>
command! -nargs=* VT vsplit | terminal <args>

nnoremap <silent> <leader>ht :HT<CR>
nnoremap <silent> <leader>vt :VT<CR>

" Make a whole-word search with <leader>/
command! -nargs=1 SearchWord call functions#SearchWord(<f-args>)
nnoremap <leader>/ :SearchWord<Space>

" Command and key mapping to enable the zoom-in and zoom-out
command! ZoomToggle call functions#ZoomToggle()
nnoremap <silent> <leader>z :ZoomToggle<CR>

" Change the default mouse scrolling wheel options
nnoremap <ScrollWheelUp>   4<C-y>
nnoremap <ScrollWheelDown> 4<C-e>
xnoremap <ScrollWheelUp>   4<C-y>
xnoremap <ScrollWheelDown> 4<C-e>

" Set a mark when moving more than 5 lines upwards/downards
" this will populate the jumplist enabling us to jump back with Ctrl-O
nnoremap <expr> k (v:count > 5 ? "m'" . v:count : "") . 'k'
nnoremap <expr> j (v:count > 5 ? "m'" . v:count : "") . 'j'

" Insert newlines below and above
nnoremap <silent> <leader>o o<Esc>kO<Esc>j

" Easiliy toggle comments, both in Normal and Insert mode
map  <leader><leader> <Plug>NERDCommenterToggle
imap <leader><leader> <C-o><Plug>NERDCommenterToggle

" Keybindings to toggle and kill the floating term window
nnoremap <silent> <leader>ft :FloatermToggle<CR>
nnoremap <silent> <leader>fk :FloatermKill<CR>
tnoremap <silent> <leader>ft <C-\><C-n>:FloatermToggle<CR>
tnoremap <silent> <leader>fk <C-\><C-n>:FloatermKill<CR>

" Git-signify keybinds to use the plugin more easily
nnoremap <silent> <leader>gh :SignifyToggleHighlight<CR>
nnoremap <silent> <leader>gf :SignifyFold<CR>
nnoremap <silent> <leader>gd :SignifyDiff<CR>
nnoremap <silent> <leader>hd :SignifyHunkDiff<CR>
nnoremap <silent> <leader>hu :SignifyHunkUndo<CR>

" Git-signify jump between git diff hunks
nmap <silent> <leader>gj <Plug>(signify-next-hunk)
nmap <silent> <leader>gk <Plug>(signify-prev-hunk)
nmap <silent> <leader>gJ 9999<leader>gj
nmap <silent> <leader>gK 9999<leader>gk

" Open git-messenger
nmap <silent> <leader>gm <Plug>(git-messenger)

" EasyAlign keybindings
" 'vipga' starts interactive EasyAlign in visual mode
" 'gaip' starts interactive EasyAlign for text/motion object
nmap ga <Plug>(EasyAlign)
xmap ga <Plug>(EasyAlign)
nmap <leader>ga <Plug>(LiveEasyAlign)
xmap <leader>ga <Plug>(LiveEasyAlign)

" Use <Tab> and <S-Tab> to navigate through the autocomplete options
inoremap <silent> <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
inoremap <silent> <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

" Alternate between header/source files
" nnoremap <silent> <leader>ko :Alternate<CR>
nnoremap <silent> <leader>ko :ClangdSwitchSourceHeader<CR>

" Git blame keybind toggle
nnoremap <silent> <leader>gb :BlamerToggle<CR>

" Also, '[q', ']q' work for cprev cnext, from vim-unimpaired
nnoremap <silent> <leader>co :copen<CR>
nnoremap <silent> <leader>cc :cclose<CR>
nnoremap <silent> <leader>cr :cexpr []<CR>

" Also '[l', ']l' work for lprev lnext, from vim-unimpaired
nnoremap <silent> <leader>lo :lopen<CR>
nnoremap <silent> <leader>lc :lclose<CR>
nnoremap <silent> <leader>lr :lexpr []<CR>

" Toggle quickfix and locationlist
nnoremap <silent> <leader>ct :call functions#ToggleList('qf')<CR>
nnoremap <silent> <leader>lt :call functions#ToggleList('loc')<CR>

" Keybindings to toggle Vista and open Vista finder more easily
nnoremap <silent> <leader>vv :Vista!!<CR>
nnoremap <silent> <leader>vf :Vista finder nvim_lsp<CR>

" Nvim-tree toggle keybinding
nnoremap <silent> <leader>nt :NvimTreeToggle<CR>
nnoremap <silent> <leader>nf :NvimTreeFindFile<CR>

" }}}

" ----------------------------------- 7. Abbreviations {{{

" Shebang abbreviation for bash in scripts
iab #! #!/usr/bin/env bash

" Add current date
iab <silent> idt Date: <C-R>=strftime('%c')<CR>

" Add Lua heredoc
iab lua< lua<<EOF<CR><CR>EOF<Up>

" }}}

" ---------------------------------- 8. Plugins extras {{{

" ----------------------------------- 1. Plugin options {{{

" Set the theme for airline/lightline according to the active colorscheme
if functions#ColorschemeActive('darcula')
  let s:_colorScheme='darculaOriginal'
elseif functions#ColorschemeActive('tokyonight')
  let s:_colorScheme='tokyonight'
elseif functions#ColorschemeActive('onedark')
  let s:_colorScheme='onedark'
elseif functions#ColorschemeActive('nightfox')
  let s:_colorScheme='nightfox'
endif

" Statusline options
" ------------------
if functions#PluginLoaded('vim-airline')

  " Airline options
  " -----------------
  " Specify the default airline theme
  let g:airline_theme=s:_colorScheme

  " Enable tabline extension
  let g:airline#extensions#tabline#enabled=1

  " Add powerline fonts to populate powerline symbols
  let g:airline_powerline_fonts=1

elseif functions#PluginLoaded('lightline.vim')

  " Lightline options
  " -------------------
  " Specify default options
  let g:lightline = {
        \ 'colorscheme': s:_colorScheme,
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
        \ },
        \ 'tabline': {
        \   'left': [ ['buffers'] ],
        \   'right': [ ['close'] ]
        \ },
        \ 'component_expand': {
        \   'buffers': 'lightline#bufferline#buffers'
        \ },
        \ 'component_type': {
        \   'buffers': 'tabsel'
        \ },
        \ 'component_function': {
        \   'gitbranch': 'FugitiveHead'
        \ },
        \ 'component_raw': {
        \   'buffers': 1
        \ },
        \}

  " Lightline-bufferline options
  " ------------------------------
  " Add devicons to the bufferline
  let g:lightline#bufferline#enable_devicons=1

  " Make buffer clickable this also requires 'component_raw': 'buffres' : 1
  let g:lightline#bufferline#clickable=1

  " Use different symbols in the buffers for modified etc
  let g:lightline#bufferline#unicode_symbols=1

  " Enable numbering on the buffers, option: 1 as shown by the :ls command
  let g:lightline#bufferline#show_number=1

  " Position the icon to the right of the buffer name
  let g:lightline#bufferline#icon_position="right"

  " This is required for lightline to show the buffers
  set showtabline=2
endif

" Committia options
" -----------------
" Committia plugin minimum width before falling back to single-col layout
let g:committia_min_window_width=140

" Goyo options
" ------------
" Goyo window configurations
let g:goyo_width="80%"
let g:goyo_height="85%"
let g:goyo_linenr=0

" Vim-Signify options
" -------------------
" Show text in the sign-column '!' '-' '+'
let g:signify_sign_show_text=1

" Change the delete sign of git-signify from '_' to '-'
let g:signify_sign_delete='-'

" Darcula vim options
" -------------------
" Better highlights for diff
if functions#ColorschemeActive('darcula')
  hi DiffAdded         guifg=#499C54
  hi DiffRemoved       guifg=#ab4b52
  hi SignifyLineDelete guibg=#ab4b52
  hi SignifySignDelete guibg=#ab4b52
endif

" Vim Current Word options
" ------------------------
" Do not highlight the word under cursor
let g:vim_current_word#highlight_current_word=0

" Highlight only focused window
let g:vim_current_word#highlight_only_in_focused_window=1

" Suda options
" ------------
" Automatically open files with sudo when needed
let g:suda_smart_edit=1

" Nerd Commenter options
" ----------------------
" Do not create default mappings
let g:NERDCreateDefaultMappings=0

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims=1

" Do not comment out empty lines
let g:NERDCommentEmptyLines=0

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace=1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign='left'

" Git blamer optionss
" -------------------
" Enable plugin and set the delay before triggering
let g:blamer_enabled=1
let g:blamer_delay=500

" Startify options
" ----------------
" Specify where to store sessions
let g:startify_session_dir='~/.vim/sessions'

" Automatically update sessions
let g:startify_session_persistence=1

" Use unicode for startify
let g:startify_fortune_use_unicode=1

" Center the header
let g:startify_custom_header='startify#center(startify#fortune#cowsay())'

" Add custom bookmarks
let g:startify_bookmarks=[{'v': '~/.vimrc'}, {'z': '~/.zshrc'}, {'a': '~/.zsh_aliases'}]

" Indent-blankline options
" ------------------------
" Change the highlight for the treesitter context, to a light gray
" highlight IndentBlanklineContextChar guifg=#545c82 gui=nocombine

" Git-messenger options
" ---------------------
" Do not allow plugin defined mappings
let g:git_messenger_no_default_mappings=v:true

" Insert cursor inside pop-up window
let g:git_messenger_always_into_popup=v:true

" Added shadow to the pop-up window
let g:git_messenger_floating_win_opts={'border': 'shadow'}

" Quick-scope options
" -------------------
" Only highlight when pressing these keys
let g:qs_highlight_on_keys=['f', 'F', 't', 'T']

" Vim-rooter options
" ------------------
" Start Rooter manually instead of automatically
let g:rooter_manual_only=1

" Vem-tabline options
" -------------------
" Always show the tabline
let g:vem_tabline_show=2

" Use multiwindow mode for tabline
let g:vem_tabline_multiwindow_mode=v:true

" Show numbers on the buffer tab
let g:vem_tabline_show_number="buffnr"

" Symbol to show after the number
let g:vem_tabline_number_symbol=" "

" Change the colors of the bufferline for onedark
if functions#ColorschemeActive('onedark')
  highlight VemTablineSelected       guifg=#282c34 guibg=#c678dd
  highlight VemTablineNumberSelected guifg=#282c34 guibg=#c678dd
endif

" Vista options
" -------------
" How each level is indented and what to prepend.
" This could make the display more compact or more spacious. e.g., more compact: ["▸ ", ""]
let g:vista_icon_indent=["╰─▸ ", "├─▸ "]

" Executive used when opening vista sidebar without specifying it.
" See all the avaliable executives via `:echo g:vista#executives`.
let g:vista_default_executive='nvim_lsp'

" Set the executive for some filetypes explicitly. Use the explicit executive
" instead of the default one for these filetypes when using `:Vista` without
" specifying the executive.
let g:vista_executive_for={'cpp': 'nvim_lsp'}

" To enable fzf's preview window set g:vista_fzf_preview.
let g:vista_fzf_preview=['right:50%']

" Enable icons
let g:vista#renderer#enable_icon=1

" How to show detailed information of current cursor symbol in Vista
let g:vista_echo_cursor_strategy='floating_win'

" Vim alternate options
" ---------------------
if functions#PluginLoaded('vim-alternate')
  " Set the alternate extension mappings
  let g:AlternateExtensionMappings=[{'.cpp' : '.h', '.h' : '.hpp', '.hpp' : '.cpp'},
        \ {'.c': '.h', '.h': '.c'}, {'.cc': '.h', '.h': '.hpp', '.hpp': '.cc'}]
endif

" Vim surround options
" --------------------
if functions#PluginLoaded('vim-surround')
  " Set extra custom replacement rule that surrounds <text> with /*<text>*/
  " 120 denotes the nr2char key which corresponds to 'x'
  let g:surround_120="/*\r*/"
endif

" }}}

" ----------------------------------- 2. Plugin configurations {{{

" ----------------------------------- 0. Simple lua plugins {{{

if functions#PluginLoaded('nvim-colorizer')

lua<<EOF
-- Setup nvim-colorizer
require'colorizer'.setup()
EOF

endif

if functions#PluginLoaded('lualine.nvim')

" Load a custom lualine theme
" https://gist.githubusercontent.com/hoob3rt/b200435a765ca18f09f83580a606b878/raw/d99388470ed5ddb1da32a0bd3bccd4a69eb15429/evil_lualine.lua
luafile ~/.vim/plugged/lualine.nvim/lua/lualine/themes/evil_lualine.lua

endif

if functions#PluginLoaded('nvim-notify')

lua<<EOF
-- Set default notify to nvim-notify
vim.notify = require("notify")
EOF

endif

"}}}

" ----------------------------------- 1. Which-key {{{

if functions#PluginLoaded('vim-which-key')

  " Map leader-space to which_key
  nnoremap <silent> <leader><Space> :silent <c-u> :silent WhichKey '<Space>'<CR>
  vnoremap <silent> <leader><Space> :silent <c-u> :silent WhichKeyVisual '<Space>'<CR>

  " Create map to add keys to
  let g:which_key_map={}

  " Define a separator
  let g:which_key_sep='→'

  " Not a fan of floating windows for this
  let g:which_key_use_floating_win=0

  " Change the colors if you want
  highlight default link WhichKey          Operator
  highlight default link WhichKeySeperator DiffAdded
  highlight default link WhichKeyGroup     Identifier
  highlight default link WhichKeyDesc      Function

  " Hide status line
  autocmd! FileType which_key
  autocmd  FileType which_key set laststatus=0 noshowmode noruler
    \| autocmd BufLeave <buffer> set laststatus=2 noshowmode ruler

  " Single mappings
  let g:which_key_map['/'] = [ '<Plug>NERDCommenterToggle', 'comment' ]
  let g:which_key_map['e'] = [ ':e .'                     , 'explorer' ]
  let g:which_key_map['f'] = [ ':Files'                   , 'search files' ]
  let g:which_key_map['R'] = [ ':Rg'                      , 'search text' ]
  let g:which_key_map['S'] = [ ':Startify'                , 'start screen' ]
  let g:which_key_map['z'] = [ ':Goyo'                    , 'zen' ]

  " s is for search
  let g:which_key_map.s = {
        \ 'name' : '+Search' ,
        \ '/' : [':History/'   , 'history'],
        \ ':' : [':Commands'   , 'commands'],
        \ 'b' : [':BLines'     , 'current buffer'],
        \ 'B' : [':Buffers'    , 'open buffers'],
        \ 'c' : [':Commits'    , 'commits'],
        \ 'C' : [':BCommits'   , 'buffer commits'],
        \ 'f' : [':Files'      , 'files'],
        \ 'g' : [':GFiles'     , 'git files'],
        \ 'G' : [':GFiles?'    , 'modified git files'],
        \ 'h' : [':History'    , 'file history'],
        \ 'H' : [':History:'   , 'command history'],
        \ 'l' : [':Lines'      , 'lines'],
        \ 'L' : [':Ls'         , 'ls'],
        \ 'm' : [':Marks'      , 'marks'],
        \ 'M' : [':Maps'       , 'normal maps'],
        \ 'p' : [':Helptags'   , 'help tags'],
        \ 'P' : [':Tags'       , 'project tags'],
        \ 's' : [':Snippets'   , 'snippets'],
        \ 'S' : [':Colors'     , 'color schemes'],
        \ 't' : [':Rg'         , 'text Ripgrep'],
        \ 'T' : [':BTags'      , 'buffer tags'],
        \ 'w' : [':Windows'    , 'search windows'],
        \ 'y' : [':Filetypes'  , 'file types'],
        \ 'z' : [':FZF'        , 'FZF'],
        \ }

  " b is for buffer
  let g:which_key_map.b = {
        \ 'name' : '+Buffer' ,
        \ 'a' : [':ball'       , 'one window per buffer'],
        \ 'd' : [':bd'         , 'delete-buffer'],
        \ 'f' : [':bfirst'     , 'first-buffer'],
        \ 'h' : [':Startify'   , 'home-buffer'],
        \ 'l' : [':blast'      , 'last-buffer'],
        \ 'n' : [':bnext'      , 'next-buffer'],
        \ 'o' : [':BufOnly'    , 'keep current buffer only'],
        \ 'p' : [':bprevious'  , 'previous-buffer'],
        \ '?' : [':Buffers'    , 'fzf-buffers'],
        \ }

  " w is for windows
  let g:which_key_map.w = {
        \ 'name' : '+Windows' ,
        \ '=' : ['<C-w>='   , 'equal windows'],
        \ '?' : [':Windows' , 'fzf windows'],
        \ 'd' : ['<C-W>c'   , 'delete-window'],
        \ 'h' : ['<C-W>h'   , 'window-left'],
        \ 'j' : ['<C-W>j'   , 'window-below'],
        \ 'l' : ['<C-W>l'   , 'window-right'],
        \ 'k' : ['<C-W>k'   , 'window-up'],
        \ 'r' : ['<C-w>r'   , 'rotate split'],
        \ 's' : ['<C-w>s'   , 'split below'],
        \ 'v' : ['<C-w>v'   , 'split right'],
        \}

  " g is for git
  let g:which_key_map.g = {
        \ 'name' : '+Git' ,
        \ 'b' : [':Git blame'  , 'blame'],
        \ 'B' : [':GBrowse'    , 'browse'],
        \ 'd' : [':Git diff'   , 'diff'],
        \ 'l' : [':Git log'    , 'log'],
        \ 'L' : [':Git lg'     , 'lg'],
        \ 's' : [':Gstatus'    , 'status'],
        \ 'S' : [':Git add'    , 'stage'],
        \ 'r' : [':Git reflog' , 'reflog'],
        \ }

  " p is for vim plug
  let g:which_key_map.p = {
        \ 'name' : '+Plug' ,
        \ 'c' : [':PlugClean'   , 'clean'],
        \ 'd' : [':PlugDiff'    , 'diff'],
        \ 'i' : [':PlugInstall' , 'install'],
        \ 's' : [':PlugStatus'  , 'status'],
        \ 'S' : [':PlugSnapshot', 'snapshot'],
        \ 'u' : [':PlugUpdate'  , 'update'],
        \ 'U' : [':PlugUpgrade' , 'upgrade'],
        \ }

  " t is for Telescope
  let g:which_key_map.t = {
        \ 'name' : '+Telescope' ,
        \ ':' : [':Telescope command_history'           , 'command history'],
        \ '/' : [':Telescope search_history'            , 'search history'],
        \ 'a' : [':Telescope autocommands'              , 'autocommands'],
        \ 'b' : [':Telescope buffers'                   , 'buffers'],
        \ 'B' : [':Telescope file_browser'              , 'file browser'],
        \ 'c' : [':Telescope commands'                  , 'commands'],
        \ 'C' : [':Telescope current_buffer_fuzzy_find' , 'current buffer lines'],
        \ 'f' : [':Telescope find_files'                , 'find files'],
        \ 'F' : [':Telescope filetypes'                 , 'filetypes'],
        \ 'g' : [':Telescope live_grep'                 , 'live grep'],
        \ 'h' : [':Telescope highlights'                , 'highlights'],
        \ 'j' : [':Telescope jumplist'                  , 'jumplist'],
        \ 'k' : [':Telescope keymaps'                   , 'keymappings'],
        \ 'l' : [':Telescope loclist'                   , 'location list'],
        \ 'm' : [':Telescope marks'                     , 'marks'],
        \ 'M' : [':Telescope man_pages'                 , 'man pages'],
        \ 'o' : [':Telescope oldfiles'                  , 'oldfiles'],
        \ 'O' : [':Telescope vim_options'               , 'vim options'],
        \ 'q' : [':Telescope quickfix'                  , 'quickfix list'],
        \ 's' : [':Telescope grep_string'               , 'search string'],
        \ 't' : [':Telescope tags'                      , 'tags'],
        \}

  " t.g is for Telescope git_*
  let g:which_key_map.t.g = {
        \ 'name' : '+Git' ,
        \ 'b' : [':Telescope git_bcommits' , 'buffer commmits'],
        \ 'c' : [':Telescope git_commits'  , 'commmits'],
        \ 'f' : [':Telescope git_files'    , 'git files'],
        \ 'h' : [':Telescope git_stash'    , 'git stash'],
        \ 'r' : [':Telescope git_branches' , 'git branches'],
        \ 's' : [':Telescope git_status'   , 'git status'],
        \}

  " t.l is for Telescope lsp_*
  let g:which_key_map.t.l = {
        \ 'name' : '+LSP' ,
        \ 'c' : [':Telescope lsp_code_actions'              , 'code actions'],
        \ 'C' : [':Telescope lsp_range_code_actions'        , 'range code actions'],
        \ 'd' : [':Telescope lsp_document_diagnostics'      , 'diagnostics'],
        \ 'D' : [':Telescope lsp_workspace_diagnostics'     , 'workspace diagnostics'],
        \ 'f' : [':Telescope lsp_definitions'               , 'definitions'],
        \ 'i' : [':Telescope lsp_implementations'           , 'implementations'],
        \ 'r' : [':Telescope lsp_references'                , 'references'],
        \ 's' : [':Telescope lsp_document_symbols'          , 'symbols'],
        \ 'S' : [':Telescope lsp_workspace_symbols'         , 'workspace symbols'],
        \ 'w' : [':Telescope lsp_dynamic_workspace_symbols' , 'dynamic workspace symbols'],
        \}

  " Register which key map
  call which_key#register('<Space>', "g:which_key_map")

endif

" }}}

" ----------------------------------- 2. Web-devicons {{{

if functions#PluginLoaded('nvim-web-devicons')

lua<<EOF
function _G.webDevIcons(path)
  local extension = vim.fn.fnamemodify(path, ':e')
  local filename = vim.fn.fnamemodify(path, ':t')
  return require'nvim-web-devicons'.get_icon(filename, extension, { default = true })
end
EOF

" Function for Startify in-order to use web-devicons in place of devicons
function! StartifyEntryFormat() abort
  return 'v:lua.webDevIcons(absolute_path) . " " . entry_path'
endfunction

" Function for vem-tabline, to get web-devicons in place of devicons
function! WebDevIconsGetFileTypeSymbol(path) abort
  return v:lua.webDevIcons(a:path)
endfunction

endif

" }}}

" ----------------------------------- 3. Specs {{{

if functions#PluginLoaded('specs.nvim')

lua<<EOF
-- Setup specs-nvim
require('specs').setup {
  show_jumps = true,
  min_jump = 30,
  popup = {
    inc_ms = 8,
    delay_ms = 0,
    blend = 5,
    width = 35,
    winhl = "PMenu",
    fader = require('specs').exp_fader,
    resizer = require('specs').shrink_resizer
  },
  ignore_buftypes = {
    nofile = true,
  },
}
EOF

endif

" }}}

" ----------------------------------- 4. FZF {{{

if functions#PluginLoaded('fzf.vim')

  " Custom fzf keybindings for searching
  " nnoremap <silent> <leader>fb :Buffers<CR>
  " nnoremap <silent> <leader>ff :Files<CR>
  " nnoremap <silent> <leader>rg :Rg<CR>
  " nnoremap <silent> <leader>fM :Marks<CR>
  " nnoremap <silent> <leader>fh :History:<CR>
  " nnoremap <silent> <leader>fm <Cmd>Maps<CR>

  " Open mappings depending on what mode we're currently using
  nmap <silent> <leader>fm <Plug>(fzf-maps-n)
  imap <silent> <leader>fm <Plug>(fzf-maps-i)
  xmap <silent> <leader>fm <Plug>(fzf-maps-x)

  " Start searching for files
  command! -bang -nargs=? -complete=dir Files
    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)

  " Execeute ls on the specified directory
  command! -bang -complete=dir -nargs=? Ls
    \ call fzf#run(fzf#wrap({'source': 'ls', 'dir': <q-args>}, <bang>0))

  " Custom RipgrepFzf function to use with Rg command
  function! RipgrepFzf(query, fullscreen)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
    let initial_command = printf(command_fmt, shellescape(a:query))
    let reload_command = printf(command_fmt, '{q}')
    " Make a centered pop-up window for Rg
    let spec = { 'window': { 'width': 0.9, 'height': 0.7 },
                \'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command] }
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
  endfunction

  " Start an interactive Ripgrep search
  command! -nargs=* -bang Rg call RipgrepFzf(<q-args>, <bang>0)

  " Make FZF colors match the active colorscheme
  let g:fzf_colors = {
        \ 'fg'      : ['fg', 'Normal'],
        \ 'bg'      : ['bg', 'Normal'],
        \ 'hl'      : ['fg', 'Comment'],
        \ 'fg+'     : ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+'     : ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+'     : ['fg', 'Statement'],
        \ 'info'    : ['fg', 'PreProc'],
        \ 'border'  : ['fg', 'Ignore'],
        \ 'prompt'  : ['fg', 'Conditional'],
        \ 'pointer' : ['fg', 'Exception'],
        \ 'marker'  : ['fg', 'Keyword'],
        \ 'spinner' : ['fg', 'Label'],
        \ 'header'  : ['fg', 'Comment']
        \}

  " Popup window (anchored to the bottom of the current window)
  " https://github.com/junegunn/fzf/blob/master/README-VIM.md
  let g:fzf_layout = {
        \ 'window':  {
          \ 'width'    : 1.0,
          \ 'height'   : 0.30,
          \ 'relative' : v:true,
          \ 'yoffset'  : 1.0,
          \ 'border'   : 'horizontal',
          \}
        \}

  " This is the default extra key bindings
  let g:fzf_action = {
        \ 'ctrl-t' : 'tab split',
        \ 'ctrl-x' : 'split',
        \ 'ctrl-v' : 'vsplit'
        \}

endif

" }}}

" ----------------------------------- 5. Tree sitter {{{

if functions#PluginLoaded('nvim-treesitter')

lua<<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    'c', 'cpp', 'json', 'python', 'lua', 'bash', 'typescript', 'javascript', 'html'
  },
  highlight = {
    enable = true,
  },
  indent = {
    enable = true,
  },
  autopairs = {
    enable = true,
  },
  autotag = {
    enable = true,
  },
  incremental_selection = {
    enable = true,
    keymaps = {
      init_selection    = "gis",
      node_incremental  = "ni",
      node_decremental  = "nd",
      scope_incremental = "si",
    }
  },
  textobjects = {
    select = {
      enable = true,
      lookahead = true, -- Automatically jump forward to textobj, similar to targets.vim
      keymaps = {
        ["af"] = "@function.outer",
        ["if"] = "@function.inner",
        ["al"] = "@loop.outer",
        ["il"] = "@loop.inner",
        ['ac'] = '@conditional.outer',
        ['ic'] = '@conditional.inner',
        ["aC"] = "@class.outer",
        ["iC"] = "@class.inner",
      },
    },
    swap = {
      enable = true,
      swap_next = {
        ["<leader>sp"] = "@parameter.inner",
        ["<leader>sm"] = "@function.outer",
      },
      swap_previous = {
        ["<leader>sP"] = "@parameter.inner",
        ["<leader>sM"] = "@function.outer",
      },
    },
    move = {
      enable = true,
      set_jumps = true,
      goto_next_start = {
        ["]m"] = "@function.outer",
        ["]c"] = "@class.outer",
      },
      goto_next_end = {
        ["]M"] = "@function.outer",
        ["]C"] = "@class.outer",
      },
      goto_previous_start = {
        ["[m"] = "@function.outer",
        ["[c"] = "@class.outer",
      },
      goto_previous_end = {
        ["[M"] = "@function.outer",
        ["[C"] = "@class.outer",
      },
    },
    lsp_interop = {
      enable = true,
      border = "none",
      peek_definition_code = {
        ["gf"] = "@function.outer",
        ["gc"] = "@class.outer",
      },
    },
    playground = {
      enable = true,
      updatetime = 25,
      persist_queries = false,
      keybindings = {
        toggle_query_editor = 'o',
        toggle_hl_groups = 'i',
        toggle_injected_languages = 't',
        toggle_anonymous_nodes = 'a',
        toggle_language_display = 'I',
        focus_language = 'f',
        unfocus_language = 'F',
        update = 'R',
        goto_node = '<cr>',
        show_help = '?',
      },
    },
  },
}
EOF

endif

" }}}

" ----------------------------------- 6. Trouble {{{

if functions#PluginLoaded('trouble.nvim')

  " Trouble list command-line sugar
  nnoremap <silent> <leader>tt :TroubleToggle<CR>
  nnoremap <silent> <leader>tw :TroubleToggle lsp_workspace_diagnostics<CR>
  nnoremap <silent> <leader>td :TroubleToggle lsp_document_diagnostics<CR>
  nnoremap <silent> <leader>tq :TroubleToggle quickfix<CR>
  nnoremap <silent> <leader>tl :TroubleToggle loclist<CR>
  nnoremap <silent> <leader>tr :TroubleToggle lsp_references<CR>

lua<<EOF
-- Setup Trouble
require'trouble'.setup {
  position = "bottom",                 -- position of the list can be: bottom, top, left, right
  height = 12,                         -- height of the trouble list when position is top or bottom
  width = 50,                          -- width of the list when position is left or right
  icons = true,                        -- use devicons for filenames
  mode = "lsp_document_diagnostics",   -- "lsp_workspace_diagnostics", "quickfix", "lsp_references", "loclist"
  fold_open = "",                     -- icon used for open folds
  fold_closed = "",                   -- icon used for closed folds
  action_keys = {                      -- key mappings for actions in the trouble list
    close = "q",                       -- close the list
    cancel = "<esc>",                  -- cancel the preview and get back to your last window / buffer / cursor
    refresh = "r",                     -- manually refresh
    jump = { "<cr>", "<tab>", "o" },   -- jump to the diagnostic or open / close folds
    jump_close = { "oc", "go" },             -- jump to the diagnostic and close the list
    toggle_mode = "m",                 -- toggle between "workspace" and "document" diagnostics mode
    toggle_preview = "P",              -- toggle auto_preview
    hover = "K",                       -- opens a small poup with the full multiline message
    preview = "p",                     -- preview the diagnostic location
    close_folds = { "zM", "zm" },      -- close all folds
    open_folds = { "zR", "zr" },       -- open all folds
    toggle_fold = { "<Space>", "za" }, -- toggle fold of current file
    previous = "<C-k>",                -- previous item
    next = "<C-j>",                    -- next item
  },
  indent_lines = true,                 -- add an indent guide below the fold icons
  auto_open = false,                   -- automatically open the list when you have diagnostics
  auto_close = false,                  -- automatically close the list when you have no diagnostics
  auto_preview = true,                 -- automatically preview the location of the diagnostic
  auto_fold = false,                   -- automatically fold a file trouble list at creation
  signs = {
    error       = "",
    information = "",
    warning     = "",
    hint        = "",
    other       = "﫠"
  },
  use_lsp_diagnostic_signs = false    -- enabling this will use the signs defined in your lsp client
}
EOF

endif

"}}}

" ----------------------------------- 7. Telescope {{{

if functions#PluginLoaded('telescope.nvim')

  " Find files using Telescope command-line sugar
  nnoremap <silent> <leader>fc <Cmd>Telescope commands<CR>
  nnoremap <silent> <leader>fH <Cmd>Telescope highlights<CR>
  nnoremap <silent> <leader>fo <Cmd>Telescope oldfiles<CR>
  nnoremap <silent> <leader>fO <Cmd>Telescope vim_options<CR>
  nnoremap <silent> <leader>fw <Cmd>Telescope grep_string<CR>
  nnoremap <silent> <leader>fT <Cmd>Telescope tags<CR>
  nnoremap <silent> <leader>fs <Cmd>Telescope lsp_document_symbols<CR>
  nnoremap <silent> <leader>f: <Cmd>Telescope command_history<CR>
  nnoremap <silent> <leader>f/ <Cmd>Telescope search_history<CR>

  " Custom commands with extra options
  nnoremap <silent> <leader>fb <Cmd>lua require'telescope.builtin'.buffers({path_display = { "shorten" }})<CR>
  nnoremap <silent> <leader>ff <Cmd>lua require'telescope.builtin'.find_files({path_display= { "shorten" }})<CR>
  nnoremap <silent> <leader>fF <Cmd>lua require'telescope.builtin'.git_files({path_display = { "shorten" }})<CR>
  nnoremap <silent> <leader>fg <Cmd>lua require'telescope.builtin'.live_grep({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fG <Cmd>lua live_grep_in_project_root()<CR>
  nnoremap <silent> <leader>fh <Cmd>lua require'telescope.builtin'.help_tags({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fl <Cmd>lua require'telescope.builtin'.current_buffer_fuzzy_find({layout_strategy = "vertical"})<CR>
  nnoremap <silent> <leader>fM <Cmd>lua require'telescope.builtin'.keymaps(require'telescope.themes'.get_dropdown({}))<CR>
  nnoremap <silent> <leader>fp <Cmd>lua find_in_project_root()<CR>
  nnoremap <silent> <leader>fS <Cmd>lua custom_grep_string()<CR>
  nnoremap <silent> <leader>fv <Cmd>lua find_in_vim_root()<CR>

lua<<EOF
local actions = require('telescope.actions')
local action_state = require('telescope.actions.state')
local trouble = require('trouble.providers.telescope')

-- Setup Telescope
require'telescope'.setup {
  defaults = {
    prompt_prefix = '❯ ',
    selection_caret = '❯ ',
    winblend = 15,
    layout_strategy = 'horizontal',
    layout_config = {
      prompt_position = "top",
      horizontal = {
        width = { padding = 0.1 },
        height = { padding = 0.1 },
        preview_width = 0.5,
        mirror = false,
      },
      vertical = {
        width = { padding = 0.1 },
        height = { padding = 0.1 },
        preview_height = 0.65,
        mirror = false,
      },
    },
    use_less = true,
    color_devicons = true,
    initial_mode = "insert",
    scroll_strategy = "cycle",
    selection_strategy = "reset",
    sorting_strategy = "ascending",
    set_env = { ['COLORTERM'] = 'truecolor' },
    borderchars = { '─', '│', '─', '│', '╭', '╮', '╯', '╰'},
    file_ignore_patterns = {},
    file_sorter = require'telescope.sorters'.get_fuzzy_file,
    generic_sorter = require'telescope.sorters'.get_generic_fuzzy_sorter,
    file_previewer = require'telescope.previewers'.vim_buffer_cat.new,
    grep_previewer = require'telescope.previewers'.vim_buffer_vimgrep.new,
    qflist_previewer = require'telescope.previewers'.vim_buffer_qflist.new,
    mappings = {
      i = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-q>"] = actions.close,
        ["<Esc>"] = actions.close,
        ["<CR>"]  = actions.select_default + actions.center,
        ["<Tab>"] = actions.toggle_selection,
        ["<C-c>"] = actions.smart_send_to_qflist  + actions.open_qflist,
        ["<C-l>"] = actions.smart_send_to_loclist + actions.open_loclist,
        ["<C-t>"] = trouble.open_with_trouble,
      },
      n = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-t>"] = trouble.open_with_trouble,
      }
    }
  },
  extensions = {
    fzf = {
      fuzzy = true,
      override_generic_sorter = true,
      override_file_sorter = true,
      case_mode = "smart_case",
    }
  }
}

-- Load extensions
require'telescope'.load_extension('fzf')

-- Custom lua function to edit ~/.vim
function find_in_vim_root()
  require'telescope.builtin'.find_files {
    prompt_title = "~/.vim",
    cwd = "~/.vim",
    follow = true,                          -- follow symbolic links
    file_ignore_patterns = { "undo%-dir" }, -- character '-' needs to be escaped
  }
end

-- Custom lua function to search from project root
-- uses vim-rooter's FindRootDirectory function
function find_in_project_root()
  require'telescope.builtin'.find_files {
    prompt_title = "Project search",
    path_display = { "shorten" },
    cwd = vim.fn.FindRootDirectory(),
  }
end

-- Custom lua function to live_grep from project root
-- uses vim-rooter's FindRootDirectory function
function live_grep_in_project_root()
  require'telescope.builtin'.live_grep {
    prompt_title = "Project root live grep",
    path_display = { "shorten" },
    cwd = vim.fn.FindRootDirectory(),
    layout_strategy = "vertical",
  }
end

-- Custom function to search for a provided string
function custom_grep_string()
  require'telescope.builtin'.grep_string {
    path_display = { "shorten" },
    search = vim.fn.input("Grep string ﯀ "),
  }
end
EOF

endif

" }}}

" ----------------------------------- 8. Nvim-cmp {{{

if functions#PluginLoaded('nvim-cmp')

lua<<EOF
-- Setup custom icons for the autocompletion
local cmp_kinds = {
  Class         = "  ",
  Color         = "  ",
  Constant      = "  ",
  Constructor   = "  ",
  Enum          = "了 ",
  EnumMember    = "  ",
  Field         = "  ",
  File          = "  ",
  Folder        = "  ",
  Function      = "ƒ  ",
  Interface     = "  ",
  Keyword       = "  ",
  Method        = "  ",
  Module        = "  ",
  Property      = "  ",
  Snippet       = "﬌  ",
  Struct        = "  ",
  Reference     = "  ",
  Text          = "  ",
  Unit          = "塞 ",
  Value         = "  ",
  Variable      = "  ",
  Operator      = "  ",
  Event         = "  ",
  TypeParameter = "  ",
}
-- Setup nvim-cmp
local cmp = require'cmp'
cmp.setup {
  completion = {
    -- Setup preselect like nvim-compe
    -- completeopt = 'menu,menuone,noinsert',
  },
  formatting = {
    format = function(entry, vim_item)
      -- Add icon for the suggestions
      vim_item.kind = (cmp_kinds[vim_item.kind] or "") .. vim_item.kind
      -- Set a name for each source
      vim_item.menu = ({
        nvim_lua = "[Lua]",
        nvim_lsp = "[LSP]",
        buffer   = "[Buffer]",
        path     = "[Path]"
      })[entry.source.name]
      return vim_item
    end
  },
  mapping = {
    ['<CR>']      = cmp.mapping.confirm(),
    ['<Tab>']     = cmp.mapping.select_next_item(),
    ['<S-Tab>']   = cmp.mapping.select_prev_item(),
    ["<C-Space>"] = cmp.mapping.complete(),
  },
  snippet = {
  },
  sources = {
    { name = "nvim_lsp" },
    { name = "nvim_lua" },
    { name = "buffer" },
    { name = "path" },
  },
}
EOF
endif

" }}}

" ----------------------------------- 9. Nvim-autopairs {{{

if functions#PluginLoaded('nvim-autopairs')

lua<<EOF
-- Setup nvim-autopairs
require'nvim-autopairs'.setup {
  disable_filetype = { "TelescopePrompt", "vim" },
  check_ts = true,
}

-- Fix <CR> for nvim-compe
require'nvim-autopairs.completion.cmp'.setup {
  map_cr = true,      -- map <CR> on insert mode
  map_complete = true -- it will auto insert `(` after select function or method item
}
EOF

endif

" }}}

" ----------------------------------- 10. Goto-preview {{{

if functions#PluginLoaded('goto-preview')

lua<<EOF
-- Setup goto-preview
require'goto-preview'.setup {
  width = 120,              -- Width of the floating window
  height = 25,              -- Height of the floating window
  opacity = 5,              -- 0-100 opacity level of the floating window where 100 is fully transparent.
  debug = false,            -- Print debug information
  post_open_hook = nil,     -- A function taking two arguments, a buffer and a window to be ran as a hook.
  default_mappings = false, -- Bind default mappings
}

local opts = { noremap = true, silent = true }
-- These keymaps are overwriting default gp and gP for pasting and keeping cursor on new line
vim.api.nvim_set_keymap("n", "gp", "<Cmd>lua require('goto-preview').goto_preview_definition()<CR>", opts)
vim.api.nvim_set_keymap("n", "gP", "<Cmd>lua require('goto-preview').close_all_win()<CR>",           opts)
EOF

endif

" }}}

" ----------------------------------- 11. Numb {{{

if functions#PluginLoaded('numb.nvim')

lua<<EOF
-- Setup numb-nvim
require'numb'.setup {
  show_numbers = true,    -- Enable 'number' for the window while peeking
  number_only = true,     -- Peek only when the command is only a number instead of when it starts with a number
  show_cursorline = true, -- Enable 'cursorline' for the window while peeking
}
EOF

endif

" }}}

" ----------------------------------- 12. LSP {{{

lua<<EOF
-- Setup LSP configurations
local on_attach = function(client, bufnr)

  -- Syntactic sugar
  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings
  local opts = { noremap = true, silent = true }
  buf_set_keymap('n', 'gD'         , '<Cmd>lua vim.lsp.buf.declaration()<CR>'                  , opts)
  buf_set_keymap('n', 'gd'         , '<Cmd>lua vim.lsp.buf.definition()<CR>'                   , opts)
  buf_set_keymap('n', 'gr'         , '<Cmd>lua vim.lsp.buf.references()<CR>'                   , opts)
  buf_set_keymap('n', 'K'          , '<Cmd>lua vim.lsp.buf.hover()<CR>'                        , opts)
  buf_set_keymap('n', '<leader>rn' , '<Cmd>lua vim.lsp.buf.rename()<CR>'                       , opts)
  buf_set_keymap('n', '<leader>ca' , '<Cmd>CodeActionMenu<CR>'                                 , opts)
  buf_set_keymap('n', '[d'         , '<Cmd>lua vim.lsp.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', ']d'         , '<Cmd>lua vim.lsp.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', 'dp'         , '<Cmd>lua vim.lsp.diagnostic.goto_prev()<CR>'             , opts)
  buf_set_keymap('n', 'dn'         , '<Cmd>lua vim.lsp.diagnostic.goto_next()<CR>'             , opts)
  buf_set_keymap('n', '<leader>ll' , '<Cmd>lua vim.lsp.diagnostic.set_loclist()<CR>'           , opts)
  buf_set_keymap('n', '<leader>ld' , '<Cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>' , opts)

  -- Set some keybinds conditional on server capabilities
  if client.resolved_capabilities.document_formatting then
    buf_set_keymap('n', '<leader>f', '<Cmd>lua vim.lsp.buf.formatting()<CR>', opts)
  end
  if client.resolved_capabilities.document_range_formatting then
    buf_set_keymap('v', '<leader>f', '<Cmd>lua vim.lsp.buf.range_formatting()<CR>', opts)
  end
end

-- Function to install and setup LSP servers
local setup_servers = function()
  -- Main setup
  require'lspinstall'.setup{}

  -- Install the required servers also takes care of installing missing servers
  local required_servers = { "cpp", "vim", "lua", "bash", "python", "typescript" }
  local installed_servers = require'lspinstall'.installed_servers()
  for _, server in pairs(required_servers) do
    if not vim.tbl_contains(installed_servers, server) then
      require'lspinstall'.install_server(server)
    end
  end

  local capabilities = vim.lsp.protocol.make_client_capabilities()
  capabilities = require('cmp_nvim_lsp').update_capabilities(capabilities)

  -- Map local buffer keybindings when the server attaches
  installed_servers = require'lspinstall'.installed_servers()
  for _, server in pairs(installed_servers) do
    require'lspconfig'[server].setup { on_attach = on_attach, capabilities = capabilities }
  end

  -- Fix 'vim' is undefined global for lua LSP
  require'lspconfig'.lua.setup {
    settings = { Lua = { diagnostics = { globals = { 'vim' } } } }
  }
end

-- Setup LSP servers
setup_servers()

-- Automatically reload after `:LspInstall <server>` so we don't have to restart neovim
require'lspinstall'.post_install_hook = function()
  setup_servers()    -- reload installed servers
  vim.cmd("bufdo e") -- this triggers the FileType autocmd that starts the server
end

-- Setup lsp-signature
require'lsp_signature'.on_attach({
  bind = true,
  doc_lines = 10,
  hint_enable = false,
  handler_opts = {
    border = "none", -- double, single, shadow, none
  },
})

-- Custom icons for LSP diagnostics
vim.fn.sign_define("LspDiagnosticsSignHint",        { text = "", numhl = "LspDiagnosticsDefaultHint" })
vim.fn.sign_define("LspDiagnosticsSignError",       { text = "", numhl = "LspDiagnosticsDefaultError" })
vim.fn.sign_define("LspDiagnosticsSignWarning",     { text = "", numhl = "LspDiagnosticsDefaultWarning" })
vim.fn.sign_define("LspDiagnosticsSignInformation", { text = "", numhl = "LspDiagnosticsDefaultInformation" })

-- Toggle LSP diagnostics on and off
vim.g.diagnostics_active = true
function _G.toggle_diagnostics()
  if vim.g.diagnostics_active then
    vim.g.diagnostics_active = false
    vim.lsp.diagnostic.disable()
  else
    vim.g.diagnostics_active = true
    vim.lsp.diagnostic.enable()
  end
  print("LSP diagnostics: " .. tostring(vim.g.diagnostics_active))
end

-- Consider this when another keybind sequence makes more sense, don't want to bind <leader>dd
-- vim.api.nvim_set_keymap('n', '<leader>dt', ':call v:lua.toggle_diagnostics()<CR>', { noremap = true, silent = true })
EOF

" Add a user defined command to call, instead of adding a mapping to <leader>dt
command! ToggleLSPDiagnostics call v:lua.toggle_diagnostics()

" }}}

" ----------------------------------- 13. Indent-blankline {{{

if functions#PluginLoaded('indent-blankline.nvim')

lua<<EOF
-- Setup indent-blankline
require'indent_blankline'.setup {
  -- char_list = { '|', '¦', '┆', '┊' },
  char = '│',
  show_first_indent_level = false,
  stricts_tabs = true,
  show_trailing_blankline_indent = false,
  show_end_of_line = true,
  filetype_exclude = { 'help', 'startify', 'gitcommit', 'vistakind' },
  buftype_exclude = { 'terminal' },
  use_treesitter = true,
  show_current_context = true,
  context_patterns = { 'class', 'function', 'method' , '^if', '^while', '^for', '^try', 'except', 'argument_list' },
}
EOF

endif

" }}}

" ----------------------------------- 14. Nvim-tree {{{

if functions#PluginLoaded('nvim-tree.lua')

lua<<EOF
 -- Setup nvim-tree
  vim.g.nvim_tree_quit_on_open = 1                -- closes the tree when you open a file
  vim.g.nvim_tree_indent_markers = 1              -- this option shows indent markers when folders are open
  vim.g.nvim_tree_hide_dotfiles = 1               -- this option hides files and folders starting with a dot `.`
  vim.g.nvim_tree_git_hl = 1                      -- will enable file highlight for git attributes (can be used without the icons)
  vim.g.nvim_tree_highlight_opened_files = 1      -- will enable folder and file icon highlight for opened files/directories
  vim.g.nvim_tree_root_folder_modifier = ':~'     -- default. See :help filename-modifiers for more options
  vim.g.nvim_tree_add_trailing = 1                -- append a trailing slash to folder names
  vim.g.nvim_tree_group_empty = 1                 -- compact folders that only contain a single folder into one node
  vim.g.nvim_tree_disable_window_picker = 0       -- will disable the window picker
  vim.g.nvim_tree_icon_padding = ' '              -- used for rendering the space between the icon and the filename.
  vim.g.nvim_tree_respect_buf_cwd = 1             -- will change cwd of nvim-tree to that of new buffer's when opening nvim-tree
  vim.g.nvim_tree_git_hl = 0                      -- disable this for better perfomance
  vim.g.nvim_tree_gitignore = 0                   -- disable this for better performance, do not respect gitignore
  vim.g.nvim_tree_ignore = {                      -- do not load and display on these folders
    '.git', 'node_modules', '.cache'
  }
  vim.g.nvim_tree_auto_ignore_ft = {              -- do not load nvim-tree for these filetypes
    'startify'
  }
  vim.g.nvim_tree_show_icons = {                  -- disable/enable icons per type, disable git for better perfomance
    git = 0,
    folders = 1,
    files = 1,
    folder_arrows = 1,
  }
  vim.g.nvim_tree_icons = {                       -- set the desired icons to display
    default = '',
    symlink = '',
    git = {
      unstaged = "✗",
      staged = "✓",
      unmerged = "",
      renamed = "➜",
      untracked = "★",
      deleted = "",
      ignored = "◌"
    },
    folder = {
      arrow_open = "",
      arrow_closed = "",
      open = "",
      default = "",
      empty = "",
      empty_open = "",
      symlink = "",
      symlink_open = "",
    },
    lsp = {
      hint = "",
      info = "",
      warning = "",
      error = "",
    }
  }

  -- Custom keybindings
  local tree_cb = require'nvim-tree.config'.nvim_tree_callback
  local nvim_tree_bindings = {
    { key = {"<CR>", "o", "<2-LeftMouse>"}, cb = tree_cb("edit") },
    { key = {"<C-]>", "+"},                 cb = tree_cb("cd") },
    { key = "<C-v>",                        cb = tree_cb("vsplit") },
    { key = "<C-x>",                        cb = tree_cb("split") },
    { key = "<C-t>",                        cb = tree_cb("tabnew") },
    { key = "<",                            cb = tree_cb("prev_sibling") },
    { key = ">",                            cb = tree_cb("next_sibling") },
    { key = "P",                            cb = tree_cb("parent_node") },
    { key = "<BS>",                         cb = tree_cb("close_node") },
    { key = "<S-CR>",                       cb = tree_cb("close_node") },
    { key = "<Tab>",                        cb = tree_cb("preview") },
    { key = "K",                            cb = tree_cb("first_sibling") },
    { key = "J",                            cb = tree_cb("last_sibling") },
    { key = "I",                            cb = tree_cb("toggle_ignored") },
    { key = "H",                            cb = tree_cb("toggle_dotfiles") },
    { key = "R",                            cb = tree_cb("refresh") },
    { key = "a",                            cb = tree_cb("create") },
    { key = "d",                            cb = tree_cb("remove") },
    { key = "r",                            cb = tree_cb("rename") },
    { key = "<C-r>",                        cb = tree_cb("full_rename") },
    { key = "x",                            cb = tree_cb("cut") },
    { key = "c",                            cb = tree_cb("copy") },
    { key = "p",                            cb = tree_cb("paste") },
    { key = "y",                            cb = tree_cb("copy_name") },
    { key = "Y",                            cb = tree_cb("copy_path") },
    { key = "gy",                           cb = tree_cb("copy_absolute_path") },
    { key = "[c",                           cb = tree_cb("prev_git_item") },
    { key = "]c",                           cb = tree_cb("next_git_item") },
    { key = "-",                            cb = tree_cb("dir_up") },
    { key = "s",                            cb = tree_cb("system_open") },
    { key = "q",                            cb = tree_cb("close") },
    { key = "g?",                           cb = tree_cb("toggle_help") },
  }

  require'nvim-tree'.setup {
    disable_netrw       = true,   -- disables netrw
    hijack_netrw        = true,   -- prevents netrw from automatically opening when opening directories
    open_on_setup       = false,  -- don't open when running setup
    ignore_ft_on_setup  = {},     -- ignore filetypes when running setup
    update_to_buf_dir   = {       -- hijacks new directory buffers when they are opened, opens the tree when typing `vim $DIR` or `vim`
      enable = true,
      auto_open = true,           -- open the tree if it was previsouly closed
    },
    auto_close          = false,  -- do not close neovim when nvim-tree is the last window
    open_on_tab         = true,   -- open tree automatically when switching tab or opening new one
    hijack_cursor       = false,  -- when moving cursor in the tree, will position the cursor at the start of the file on the current line
    update_cwd          = true,   -- update the tree cwd when changing nvim's directory (DirChanged event)
    lsp_diagnostics     = false,  -- do not show LSP diagnostics in nvim-tree
    update_focused_file = {       -- do not update tree to follow the focused file
      enable      = false,
      update_cwd  = false,        -- update the root directory of the tree to the one of the folder containing the file
      ignore_list = {}
    },
    system_open = {               -- configuration options for the system command, 's' in the tree by default
      cmd  = nil,                 -- the command to run, nil should work on most cases
      args = {}                   -- the command arguments as a list
    },
    view = {                      -- configuration options for the view
      width = 45,                 -- width of the window, can be either columns or string in '%'
      height = 30,                -- height of the window, can be either columns or string in '%'
      side = 'left',              -- the side where the tree should open
      auto_resize = true,         -- resize the tree when opening a file
      mappings = {
        custom_only = true,       -- disable default keybindings
        list = nvim_tree_bindings -- set our own custom keybindings
      }
    }
  }
EOF

endif

" }}}

" }}}

" }}}

